#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "bookman" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 2cm
\rightmargin 1cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*
Bienvenue dans le cours de script shell linux 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Quelques bases du terminal 
\end_layout

\begin_layout Standard
Avant de commencer, essayons de connaître notre terminal.
 Sachez qu'il existe plusieurs types de terminal.
 Lorsque vous êtes débutant, le terminal que vous utilisez n'est pas un
 vrai terminal, désolé de vous décevoir.
 Le terminal que vous utilisez principalement quand vous prenez en main
 linux est généralement le terminal 
\begin_inset Quotes eld
\end_inset

Konsole
\begin_inset Quotes erd
\end_inset

.
 Il s'agit d'un émulateur de terminal, c'est à dire une interface graphique
 utilisant les mêmes programmes qu'un vrai terminal mais avec un visuel
 plus pratique et plus 
\begin_inset Quotes eld
\end_inset

jolie
\begin_inset Quotes erd
\end_inset

.
 Pour voir de vrai terminal, cherchez l'installation d'une ArchLinux.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Konsole
\begin_inset Quotes erd
\end_inset

 est donc logiciel émulateur parmi tant d'autre de diffèrents types (alacritty,
 kitty) programmé en diffèrents languages (Rust pour l'émulateur Wezterm).
 Attention, ne confondez pas le language de programmation utilisé pour faire
 fonctionner votre terminal émulé et le langage interprété utilisé par votre
 terminal.
 Le language interprété par votre terminal est le langage entre vous et
 votre machine, ce sont ce qu'on appelle des languages shells.
 Ces languages sont assez universel dans le sens où si votre OS (système
 d'exploitation) est cassé, vous pouvez toujours essayer de le récuperer
 en accédant au terminal ( au vrai ! ) de votre machine, l'installation
 d'ArchLinux se fait par exemple purement avec le language interpreté Bash.
 Bash , le language interprété de base sur tout le système linux.
 Il en exite tout une famille, chacun intégrant ses propres fonctionnalités,
 d'autres en reprenant certaines fonctionnalités d'un langage de base et
 en apportant une touche personnel (oui, de la même façon que vous pouvez
 créer votre propre distibution linux, vous pouvez aussi créer votre propre
 language !).
 On retrouve notamment le ksh, le zsh, le csh ou encore le tcsh.
 Pour vous faire une idée de la diffèrence, voyez le csh comme une version
 de Bash codé en C, et tcsh comme une version de csh avec des fonctions
 supplémentaires.
 
\end_layout

\begin_layout Standard
Vous pouvez donc 
\begin_inset Quotes eld
\end_inset

parler à votre shell
\begin_inset Quotes erd
\end_inset

 de diffèrentes façons, le plus important c'est que vous sachiez dans quelle
 langue vous échanger, c'est plus pratique ! 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection*
Connaitre le type de language utilisé par votre terminal émulé
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat /etc/passwd | grep "clement"
\end_layout

\begin_layout Plain Layout

	clement:x:1000:1000:clement,,,:/home/clement:/bin/bash 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ce que vous voyez, n'est qu'une partie infime du fichier passwd.
 Ce fichier se situe dans le répertoire /etc/ , il comprend toute les informatio
ns concernant les utilisateurs, leur dernière connexion, ainsi que beaucoup
 de lignes illisibles ( voyez par vous même en tapant simplement 
\begin_inset Quotes eld
\end_inset

 cat /etc/passwd 
\begin_inset Quotes eld
\end_inset

 ) .
 La sortie de la commande cat est envoyée ( via le pipe | ) en entré de
 la commande grep.
 Voyez le grep comme une sorte de filtre ou de harçon qui cherchera tout
 les occurences que vous lui passerez en paramètre.
 Ainsi, la commande ci dessus vous ressort LA ligne possèdent l'occurence
 clement dans le fichier passwd.
 Cette ligne est assez laide, mais simple à comprendre.
 Elle est composé de diffèrent champs séparés par des 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 .
 Le premier champs vous indique le nom d'utilisateur.
 En deuxième position vous retrouvez le mode passe de l'utilisateur ( caché
 par 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 ), les 2 nombres qui suivent correspondent respectivement à votre uid ainsi
 que votre gid ( vos identifiant vu par l'ordinateur en tant qu'utilisateur
 et le groupe auquel vous appartenez ) .
 Le 5ème champs correspond à votre groupe d'appartenance ( vous pouvez faire
 partie de différents groupes ).
 Ensuite, vous retrouvez votre dossier d'utilisateur et enfin le language
 utilisé par votre shell.
 
\end_layout

\begin_layout Standard
Les diffèrents langages shell à votre disposition sont stockés dans le fichier
 /etc/shells
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat /etc/shells
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# /etc/shells: valid login shells 
\end_layout

\begin_layout Plain Layout

/bin/sh 
\end_layout

\begin_layout Plain Layout

/bin/bash 
\end_layout

\begin_layout Plain Layout

/usr/bin/bash 
\end_layout

\begin_layout Plain Layout

/bin/rbash 
\end_layout

\begin_layout Plain Layout

/usr/bin/rbash 
\end_layout

\begin_layout Plain Layout

/bin/dash 
\end_layout

\begin_layout Plain Layout

/usr/bin/dash 
\end_layout

\begin_layout Plain Layout

/usr/bin/sh 
\end_layout

\begin_layout Plain Layout

/bin/ksh93 
\end_layout

\begin_layout Plain Layout

/usr/bin/ksh93 
\end_layout

\begin_layout Plain Layout

/bin/rksh93 
\end_layout

\begin_layout Plain Layout

/usr/bin/rksh93 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vous pouvez changer votre shell en utilisant la commande 
\begin_inset Quotes eld
\end_inset

chsh
\begin_inset Quotes erd
\end_inset

 .
 Celle ci vous demandera votre mot de base et ensuite le chemin de votre
 nouveau shell ( doit figuré parmi la liste du fichier shells).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Quelques fonctions de base
\end_layout

\begin_layout Standard
Avant de parler de fonctions essentielles pour discuter avec votre ordinateur,
 il faut faire une diffèrence entre les commandes internes et externes.
\end_layout

\begin_layout Standard
Les commandes internes sont les commandes propres à votre shell, elles ont
 directement été integré lors de la progrommation de votre terminal.
\end_layout

\begin_layout Standard
Les commandes externes sont les commandes utilisable par tout type de shell,
 que ca soit bash, ksh ...ect.
 Elles correspondent à des fonction utilisable par tout les programmes que
 ca soit terminal ou encore un navigateur web.
 Elles sont généralement installer lors de l'installation de Linux, vous
 pouvez donc toujours en installer pour les utiliser dans votre Shell.
 
\end_layout

\begin_layout Standard
Pour savoir à quel type appartiennent les fonctions vous pouvez utilisez
 la commande 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ type cat
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	cat est haché (/usr/bin/cat) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comme vous pouvez le voir la commande cat ( permettant d'afficher un fichier
 ou un resultat ) est une fonction externe, elle se situe dans le dossier
 /bin ( le dossier où se situe tous vos éxecutables ).
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ type pwd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	pwd est une primitive du shell 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

pwd
\begin_inset Quotes erd
\end_inset

 qui vous permet de savoir où vous vous situez est une commande interne
 au shell
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ type ll
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ll est un alias vers « ls -alF »
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ll est un alias qui fait référence à la commande ls, nous verrons dans la
 suite l'utilité des alias.
\end_layout

\begin_layout Paragraph
En cas de doute sur une quelconque commande, vous pouvez acceder à la documentat
ion grace à la commande 
\begin_inset Quotes eld
\end_inset

man
\begin_inset Quotes erd
\end_inset

.
 Si man ne marche pas verifiez si les commandes ont une option 
\begin_inset Quotes eld
\end_inset

- - help
\begin_inset Quotes erd
\end_inset

 (tiré collé) ou juste 
\begin_inset Quotes eld
\end_inset

-h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph
who 
\end_layout

\begin_layout Standard
permet de savoir qui sont les personnes connecté sur un serveur.
 Si vous ne possèdez qu'un seul ordinateur qui vous appartient, il est bien
 sûr évident que vous soyez la seul personne sur votre serveur.
\end_layout

\begin_layout Paragraph
echo
\end_layout

\begin_layout Standard
echo [paramètre] [argument]
\end_layout

\begin_layout Standard
echo permet d'afficher du texte.
 il possède diffèrents paramètres : 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 permet de ne pas sauter de ligne jusqu'au prochain echo
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-e
\begin_inset Quotes erd
\end_inset

 permet d'utiliser les caractères ayant une action particulière ( 
\backslash
t pour tabuler 
\backslash
n pour passer à la ligne ...ect)
\end_layout

\begin_layout Paragraph*
Les caractères de substitutions 
\end_layout

\begin_layout Standard
Ils permettent de faire référence à des fichiers ou des objets qu'on ne
 sait pas entièrement nommer.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
caractère
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rôle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remplace une chaine de longueur variable voir vide
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remplace un caractère unique quelconque
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[ .
 .
 .
 ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
une série ou une plage de caractère
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[a-b]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
un caractère parmi la plage indiqué
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[! .
 .
 .
 ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inversion de la recherche
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[^ .
 .
 .
 ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inversion de la recherche
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
désigne un caractère quelconque
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
désigne un début de ligne
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
désigne une fin de ligne
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
protège le caractère suivant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{nbr}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
désigne une répétition du caractère ou de la substition précedente
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
fichiers commencants par a : a*
\end_layout

\begin_layout Itemize
fichiers de 4 caractères commencant par a : a???
\end_layout

\begin_layout Itemize
fichier d'au moins 3 caractères commencant par b : b??*
\end_layout

\begin_layout Itemize
fichier finissant par 1 ou 2 : *[12]
\end_layout

\begin_layout Itemize
fichier commencant par un caractère dans la plage a-e possèdant au moins
 un caractère avant la terminaison de 1 ou 2 : [a-e]?*[12]
\end_layout

\begin_layout Itemize
fichier ne finissant pas par 3 : *[!3]
\end_layout

\begin_layout Itemize
.* : ligne quelconque
\end_layout

\begin_layout Itemize
^$ : ligne vide
\end_layout

\begin_layout Itemize
^[123] : ligne commencant par 1,2 ou 3
\end_layout

\begin_layout Itemize

\backslash
*.
\backslash

\backslash
 : ligne contenant un caractère * (protégé), suivi d'un caractère quelconque,
 suivi d'un caractère 
\backslash
 (protégé)
\end_layout

\begin_layout Itemize
$[A-Z]{2} : ligne finissant par 2 majuscules
\end_layout

\begin_layout Standard
On peut utiliser ces méta-caractère pour faire de la conversion de caractères
 : 
\end_layout

\begin_layout Itemize
conversion minuscule 
\begin_inset Formula $\implies$
\end_inset

 MAJUSCULE 
\end_layout

\begin_deeper
\begin_layout Itemize
seulement la première lettre :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

linux c'est bien
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine^}
\end_layout

\begin_layout Plain Layout

	Linux c'est bien
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
toutes les lettres
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

linux c'est bien
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine^^}
\end_layout

\begin_layout Plain Layout

	LINUX C'EST BIEN
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
conversion MAJUSCULE 
\begin_inset Formula $\implies$
\end_inset

 minuscules
\end_layout

\begin_deeper
\begin_layout Itemize
seulement la premiere lettre 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

LINUX C'EST BIEN
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine,}
\end_layout

\begin_layout Plain Layout

	lINUX C'EST BIEN
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
toutes les lettres
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

LINUX C'EST BIEN
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine,,}
\end_layout

\begin_layout Plain Layout

	linux c'est bien
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
substitution / remplacement de motif
\end_layout

\begin_layout Standard
On peut remplacer une occurence dans des variables avec 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

une simple chaine
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine/simple/longue}
\end_layout

\begin_layout Plain Layout

	une longue chaine
\end_layout

\begin_layout Plain Layout

$ echo ${chaine/simple/
\backslash
/}  # attention caractère protégé 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	une / chaine
\end_layout

\begin_layout Plain Layout

$ echo ${chaine/a*e/aise}
\end_layout

\begin_layout Plain Layout

	une simple chaise
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
les caractères protégés correspondent à des caractères qui peuvent être
 interprétés diffèremment que ce que vous pensez, par exemple si vous voulez
 recherchez les fichiers pdf , une première approche serai de lister avec
 la commande 
\begin_inset Quotes eld
\end_inset

ls 
\begin_inset Quotes eld
\end_inset

*.pdf
\begin_inset Quotes erd
\end_inset

.
 Cependant le shell va comprendre le point comme un caractère quelconque,
 par exemple si un fichier s'appele 
\begin_inset Quotes eld
\end_inset

fichierpdf
\begin_inset Quotes erd
\end_inset

 , le shell va vous lister le fichier alors que ce n'est pas un fichier
 avec la bonne terminaison .pdf.
 La commande 
\begin_inset Quotes eld
\end_inset

ls 
\begin_inset Quotes eld
\end_inset

*
\backslash
.pdf
\begin_inset Quotes erd
\end_inset

 sera donc plus appropriée ( on veut absolument que ce soit le caractère
 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 à cet emplacement, en le protégeant ).
 
\end_layout

\begin_layout Standard
Si on veut remplacer un même motif plusieurs fois, on utilise //
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

mon premier script
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine//r/
\backslash
?}  #caractère protégé 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	mon p?emie? s?ipt
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
find
\end_layout

\begin_layout Standard
find comme son nom l'indique permet de chercher l'emplacement de fichier
 ou répertoire.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
commande
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-print
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
affiche le resultat (le resultat n'est pas afficher à l'utililsateur de
 base
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-exec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
execute une action (commande) sur les fichiers trouvés
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche suivant la chaine
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-mtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche date de derniere modif
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
–atime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche date du dernier accées
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-ctime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche sur la date de création
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-newer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche les objet plus récent qu'un fichier
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche critère de taille ( find -size +100k : fichier de plus de 100
 kilo-octet)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche sur le type de l'objet (d pour dossier, f fichier ordinaire...) d'autre
 existe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-ok
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pareil que -exec mais demande la permission
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-ls
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
affiche des info détaillé sur les objets trouvés
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-perm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche suivant la permission d'accès au fichier
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-user, -group
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recherche suivant l'appartenance du fichier
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
-mtime 1 : modif hier, -mtime +2 : modif il y a + de 2j, -mtime -3 ; modif
 il y a moins de 3 jours
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
On peut imaginer toute sorte de combinaison pour trouver des fichiers
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ find 
\backslash
(-type d -o -type f 
\backslash
) 
\backslash
(-name 
\begin_inset Quotes eld
\end_inset

*[!5]
\begin_inset Quotes erd
\end_inset

 -a -name 
\begin_inset Quotes eld
\end_inset

Ex*
\backslash
) -size +500k -mtime -10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette commande recherche dans l'ordre : 
\end_layout

\begin_layout Itemize
l'objet est soit un fichier, soit un repertoire
\end_layout

\begin_layout Itemize
le nom de l'objet ne finit pas par 5 et commence par Ex
\end_layout

\begin_layout Itemize
sa taille est supérieur à 500 kilo-octets
\end_layout

\begin_layout Itemize
la date de modification du fichier est inférieur à 10 jours
\end_layout

\begin_layout Standard
Pour executer des actions sur certains fichiers, il faut terminer la commande
 -exec ou -ok par un 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 et pour que celui-ci soit correctement interprété par le shell, il faut
 le protégé en mettant un 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

.
 Pour exécuter la commande sur le fichier trouvé, on substitue par 
\begin_inset Quotes eld
\end_inset

{}
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ touch .test .exemple .bin
\end_layout

\begin_layout Plain Layout

$ find `pwd` -name 
\begin_inset Quotes eld
\end_inset

.*
\begin_inset Quotes erd
\end_inset

 -ok rm {} 
\backslash
;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cette commande va, après avoir demandé la permission, supprimer les fichiers
 cachés.
\end_layout

\begin_layout Subsection*
Les Filtres
\end_layout

\begin_layout Standard
Il existe diffèrents filtres dans linux, nous verrons les plus utiles.
\end_layout

\begin_layout Paragraph
grep
\end_layout

\begin_layout Standard
grep [option] [fichier1, fichier2...]
\end_layout

\begin_layout Standard
Nous avons déja utilisé cette commande, elle permet de chercher toute les
 occurences d'une chaine passer en paramètre.
 Elle possède diffèrentes options :
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-v
\begin_inset Quotes erd
\end_inset

 effectue la recherche inverse : toutes les lignes ne correspondant pas
 aux critères passés en paramètre
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-c
\begin_inset Quotes erd
\end_inset

 ne retourne que le nombre de lignes trouvées
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-i
\begin_inset Quotes erd
\end_inset

 ne différencie pas les minuscules et les majuscules
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-n
\begin_inset Quotes erd
\end_inset

 indique le numero de ligne
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 dans le cas de fichier multiple, indique le fichier où apparait l'occurence
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ grep -l -v 
\begin_inset Quotes eld
\end_inset

?*
\begin_inset Quotes erd
\end_inset

 [fichier2 fichier10]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette ligne recherche les occurences de plus d'un caractère dans les fichier
 2 et 10 (attention a la négation) et indique les fichiers.
\end_layout

\begin_layout Paragraph*
wc
\end_layout

\begin_layout Standard
wc [option] [fichier1, fichier2...]
\end_layout

\begin_layout Standard
word count, vous compte le nombre de ligne, le nombre de mot ainsi que le
 nombre de caractère dans un fichier.
 Vous pouvez bien sûr spécifier si vous voulez un seul de ces résultats.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-l
\begin_inset Quotes erd
\end_inset

 indique seulement le nombre de lignes
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-w
\begin_inset Quotes erd
\end_inset

 indique le nombre de mots
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

-m
\begin_inset Quotes erd
\end_inset

 indique le nombre de caractères
\end_layout

\begin_layout Paragraph*
sort
\end_layout

\begin_layout Standard
sort permet de trier un fichier qui se trouve sous la forme d'un tableau.
\end_layout

\begin_layout Standard
sort [option] [-k pos1, pos2...] [fichier1,fichier2...]
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rôle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tri dictionnaire
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tri numérique(pour les valeur)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ignore les espaces en début de champs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aucune diffèrence entre majuscule et minuscule
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tri ordre décroissant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-tc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
change le délimiteur des champs
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ sort -n -r -tc 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 -k 2 fichier1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette commande tri les valeur de la colonne 2 dans l'ordre décroissant du
 fichier 1, les valeurs étant délimité par le caractère ;
\end_layout

\begin_layout Paragraph*
cut
\end_layout

\begin_layout Standard
dans un fichier, un caractère représente une colonne.
 
\end_layout

\begin_layout Standard
cut [-c pos1, pos2 ..] fichier 
\end_layout

\begin_layout Itemize
-c2 coupe seulement la colonne 2
\end_layout

\begin_layout Itemize
-c1-10 coupe les colonne de 1 à 10
\end_layout

\begin_layout Itemize
-c1,3,8 coupe les colonnes 1, 3 et 8
\end_layout

\begin_layout Standard
Cependant, cut permet aussi (et surtout) de selectionner un ou des champs
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correspont au délimiteur utilisé
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
champs à selectionner
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cut -d 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 -f 1,4 etc/passwd
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette commande vous affiche les colonnes 1 et 4 du fichier passwd ( les
 champs sont séparé par 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

, vérifiez le ! ) .
\end_layout

\begin_layout Paragraph*
uniq
\end_layout

\begin_layout Standard
supprime les doublons
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cut -d: -f4 fichier1 | sort -n | uniq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dans cette commande les actions suivantes sont faites dans l'ordre :
\end_layout

\begin_layout Itemize
selection de la colonne 4 de fichier1 dont les champs sont séparés par :
\end_layout

\begin_layout Itemize
la sortie est envoyée à sort qui trie les valeurs numériques dans l'ordre
 croissant
\end_layout

\begin_layout Itemize
la sortie est envoyée dans la fonction uniq qui affiche le résultat sans
 doublon
\end_layout

\begin_layout Paragraph*
paste
\end_layout

\begin_layout Standard
Permet de concatener un fichier ligne à ligne
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat fichier1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

l1
\end_layout

\begin_layout Plain Layout

l2
\end_layout

\begin_layout Plain Layout

l3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ cat fichier2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

l4
\end_layout

\begin_layout Plain Layout

l5
\end_layout

\begin_layout Plain Layout

l6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ paste -d: fichier1 fichier2
\end_layout

\begin_layout Plain Layout

l1:l4
\end_layout

\begin_layout Plain Layout

l2:l5
\end_layout

\begin_layout Plain Layout

l3:l6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Formatage de fichier
\end_layout

\begin_layout Paragraph*
tr
\end_layout

\begin_layout Standard
Permet de substituer des caractères.
 Cette commande est pratique pour convertir des minuscules en majuscules
 ou inversement.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat liste | tr 
\begin_inset Quotes eld
\end_inset

[a-z]
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

[A-Z]
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tous les caractères minuscules du fichier liste est transformé en majuscule.
\end_layout

\begin_layout Paragraph*
expand unexpand
\end_layout

\begin_layout Standard
Certaines commandes s'attendent à obtenir des tabulations comme séparateur
 de champs (comme cut par exemple).
 On a 2 commande à disposition : la commande expand convertit les tabulation
 en espace et unexpand fait le contraire.
\end_layout

\begin_layout Paragraph*
head, tail
\end_layout

\begin_layout Standard
Pour afficher le début d'un fichier on utilise la commande head, pour voir
 la fin, la commande tail.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ head -4 fichier 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cette commande affiche les 4 premières lignes de fichier
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ tail -4 fichier 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cette commande affiche les 4 dernières lignes de fichier
\end_layout

\begin_layout Subsection*
Stockage
\end_layout

\begin_layout Paragraph
du
\end_layout

\begin_layout Standard
Pour connaître l'espace utilisé par un repertoire, on utilise la commande
 
\begin_inset Quotes eld
\end_inset

du
\begin_inset Quotes erd
\end_inset

.
 Elles possèdent 2 options principalement : -k pour afficher la taille en
 kilo-octet et -s pour faire la somme.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ du -sk *
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette commande affiche la taille de chaque repertoire et fichier contenu
 dans le repertoire à l'emplacement où est exécutée la commande
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ du -sk .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cette commande affiche la taille total du repertoire.
\end_layout

\begin_layout Standard
L'option -h permet de mieux interprètait la somme par l'homme en cas de
 gros stockage.
\end_layout

\begin_layout Section
Script Bash, ksh, csh
\end_layout

\begin_layout Paragraph*
Variable
\end_layout

\begin_layout Standard
l'affectation d'une variable se fait avec le signe 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

 sans séparation d'espace avant et après le signe.
 Pour accéder au contenu d'une variable, on place le signe 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

 devant.
 Si on veut affecter une chaine de caractère à une variable, on la place
 entre guillemet ou entre apostrophe.
 La différence entre les guillemets et les apostrophes est l'interprétation
 des variables et des substitutions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ a=Jules
\end_layout

\begin_layout Plain Layout

$ b=Cesar
\end_layout

\begin_layout Plain Layout

$ c=
\begin_inset Quotes erd
\end_inset

$a $b a conquis le Gaule
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ d='$a $b a conquis la Gaule'
\end_layout

\begin_layout Plain Layout

$ echo $c
\end_layout

\begin_layout Plain Layout

	Jules Cesar a conquis la Gaule
\end_layout

\begin_layout Plain Layout

$ echo $d
\end_layout

\begin_layout Plain Layout

	$a $b a conquis la Gaule
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
On peut retirer l'affectation d'une variable avec la commande 
\begin_inset Quotes eld
\end_inset

unset
\begin_inset Quotes erd
\end_inset

 .
 
\end_layout

\begin_layout Standard
On peut affecter le résultat d'une commande à une variable, par exemple
 si on prend la cmomande date quiressort la date et qu'on le stocke dans
 une variable nommée D, on utilise les ` ` (altgr + 7).
 On peut aussi utiliser $(..).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ D=`date`   #ou D=$(date)
\end_layout

\begin_layout Plain Layout

$ cat $D
\end_layout

\begin_layout Plain Layout

	19 mars 2023 18h51 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On peut éliminer ce qui se trouve
\end_layout

\begin_layout Itemize
avant un premier motif dans une chaîne avec 
\begin_inset Quotes eld
\end_inset

#*
\begin_inset Quotes erd
\end_inset

 et en utilisant les accolades !! 
\end_layout

\begin_layout Itemize
après le dernier motif, on utilise 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
avant la dernière apparition d'un motif on utilise 
\begin_inset Quotes eld
\end_inset

##
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
après la première apparition d'un motif, on utilise 
\begin_inset Quotes eld
\end_inset

%%
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

j'aime linux
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine#*' '} 
\end_layout

\begin_layout Plain Layout

	linux
\end_layout

\begin_layout Plain Layout

$ echo ${chaine%i*}
\end_layout

\begin_layout Plain Layout

	j'aime l
\end_layout

\begin_layout Plain Layout

$ echo ${chaine##*i}
\end_layout

\begin_layout Plain Layout

	nux
\end_layout

\begin_layout Plain Layout

$ echo ${chaine%%i*}
\end_layout

\begin_layout Plain Layout

	j'a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour récupérer une certaine partie d'un éléments, on utilise les 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ chaine=
\begin_inset Quotes erd
\end_inset

j'aime linux
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

$ echo ${chaine:2:10}
\end_layout

\begin_layout Plain Layout

	aime linux
\end_layout

\begin_layout Plain Layout

$ echo ${chaine:2}
\end_layout

\begin_layout Plain Layout

	aime linux
\end_layout

\begin_layout Plain Layout

$ echo ${chaine::2}
\end_layout

\begin_layout Plain Layout

	j'
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Accolades et remplacement conditionnel
\end_layout

\begin_layout Standard
Selon la présence ou non d'une variable, il est possible de remplacer sa
 valeur par une autre :
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remplacement
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
signification
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{x:-texte}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
si la variable x est vide ou inexistante, texte prendra la place de x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{x:=texte}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
si x est vide ou inexistante alors x prendra la valeur de texte
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{x:+texte}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
si x est définit et non vide, texte prendra sa place sinon une chaine vide
 prend sa place
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{x:?texte}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
si x est vide ou inexistant, le sript est interrompu et le message texte
 s'affiche
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Longueur d'une chaîne
\end_layout

\begin_layout Standard
On obtient la longueur d'une chaîne avec le caractère 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ a=Jules
\end_layout

\begin_layout Plain Layout

$ echo 
\begin_inset Quotes eld
\end_inset

longueur de $a : ${#a}
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	longueur de Jules : 5
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Tableau et champs
\end_layout

\begin_layout Itemize
Cas du BASH
\end_layout

\begin_layout Standard
Deux moyen sont disponibles pour déclarer un tableau, l'un avec l'utilisation
 des crochets [], l'autre avec la création globale.
 Le premier élement est 0, le dernier 1023.
 Pour accéder au contenu du tableau, il faut mettre la varible ET l'elément
 entre accolade {}.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ nom[0]=Jules
\end_layout

\begin_layout Plain Layout

$ nom[1]=Romain
\end_layout

\begin_layout Plain Layout

$ echo ${nom[0]}
\end_layout

\begin_layout Plain Layout

	Jules
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ou 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ nom=(Jules Romain)
\end_layout

\begin_layout Plain Layout

$ echo ${nom[1]}
\end_layout

\begin_layout Plain Layout

	Romain
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour lister tous les élements, on utilise 
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ echo ${nom[*]}
\end_layout

\begin_layout Plain Layout

	Jules Romain
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour connaitre le nombre d'élements :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ echo ${#nom[*]}
\end_layout

\begin_layout Plain Layout

	2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si l'index est une variable, on ne met pas le $ devant celui-ci ( pratique
 pour faire des boucles sur les élements d'un tableau).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ index=0
\end_layout

\begin_layout Plain Layout

$ echo ${nom[index]}
\end_layout

\begin_layout Plain Layout

	Jules
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour ajouter un élément, on ajoute comme une simple variable avec +=(..) ,
 ne pas oublier les parenthèses.
\end_layout

\begin_layout Itemize
cas du KSH
\end_layout

\begin_layout Standard
Avec le KSh, on déclare un tableau avec set -A
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/ksh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

set -A tab un deux trois
\end_layout

\begin_layout Plain Layout

print tab[2]  #on peut utiliser print dans ksh et csh
\end_layout

\begin_layout Plain Layout

	deux
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
calcul 
\end_layout

\begin_layout Standard
Les variables peuvent être typée en entier avec la commande typset -i.
 la commande let ou ((..)) permet des calculs sur les variables.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ resultat=6*7
\end_layout

\begin_layout Plain Layout

$ add=5
\end_layout

\begin_layout Plain Layout

$ let add+=add resultat*=add
\end_layout

\begin_layout Plain Layout

$ echo $resultat
\end_layout

\begin_layout Plain Layout

	630
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On peut effectuer les opérations entre double parenthèse 
\end_layout

\begin_layout Paragraph
Argument d'un script
\end_layout

\begin_layout Standard
Lorsque l'on execute un script, on peut lui passer certains paramètres pour
 faire leur faire un traitement.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
contenu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nom de la commande (du script)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$1-9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
paramètre passé en script
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nombre total de paramètre passé
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
liste de tous les paramètres
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
liste des paramètres sous forme d'élement distinct 
\begin_inset Quotes eld
\end_inset

$1
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

$2
\begin_inset Quotes erd
\end_inset

,...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ echo $0
\end_layout

\begin_layout Plain Layout

$ echo liste $*
\end_layout

\begin_layout Plain Layout

$ echo element $@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

./Monprog un 
\begin_inset Quotes eld
\end_inset

deux trois
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	Monprog
\end_layout

\begin_layout Plain Layout

	un deux trois
\end_layout

\begin_layout Plain Layout

	un deux trois
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
la diffèrence entre $@ et $* est subtile 
\begin_inset Quotes eld
\end_inset

deux trois
\begin_inset Quotes erd
\end_inset

 est pris comme un élement simple dans $* alors qu'il est découpé en 2 dans
 $@.
\end_layout

\begin_layout Paragraph
Test 
\end_layout

\begin_layout Standard
La commande test permet d'effectuer des test de conditions.
 Le résultat est récupérable par la variable $?
\end_layout

\begin_layout Itemize
Test sur des chaînes :
\end_layout

\begin_deeper
\begin_layout Itemize
test -z 
\begin_inset Quotes eld
\end_inset

variable
\begin_inset Quotes erd
\end_inset

 : zero, retour OK si la variable est vide
\end_layout

\begin_layout Itemize
test -n 
\begin_inset Quotes eld
\end_inset

variable
\begin_inset Quotes erd
\end_inset

 non zero, retour OK si la variable est non vide
\end_layout

\begin_layout Itemize
test 
\begin_inset Quotes eld
\end_inset

variable
\begin_inset Quotes erd
\end_inset

 = chaine : OK si les 2 chaines sont identiques
\end_layout

\begin_layout Itemize
test 
\begin_inset Quotes eld
\end_inset

variable
\begin_inset Quotes erd
\end_inset

 ! = chaine : OK si les 2 chaines sont diffèrentes
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ a=
\end_layout

\begin_layout Plain Layout

$ test -z 
\begin_inset Quotes eld
\end_inset

$a
\begin_inset Quotes erd
\end_inset

; echo $?
\end_layout

\begin_layout Plain Layout

	0
\end_layout

\begin_layout Plain Layout

$ test -n 
\begin_inset Quotes eld
\end_inset

$a
\begin_inset Quotes erd
\end_inset

; echo $?
\end_layout

\begin_layout Plain Layout

	1
\end_layout

\begin_layout Plain Layout

$ a=Jules
\end_layout

\begin_layout Plain Layout

$ test 
\begin_inset Quotes eld
\end_inset

$a
\begin_inset Quotes erd
\end_inset

 = Jules ; echo $?
\end_layout

\begin_layout Plain Layout

	0
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Attention à bien placer les variables contenant du texte entre guillemet.
 Dans le cas contraire un bug se produira si la variable est vide.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ a=
\end_layout

\begin_layout Plain Layout

$ b=toto
\end_layout

\begin_layout Plain Layout

$ [ $a = $b ] && echo 
\begin_inset Quotes eld
\end_inset

ok
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	bash: [: = : unary operator expected
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alors que 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ [ 
\begin_inset Quotes eld
\end_inset

$a
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

$b
\begin_inset Quotes erd
\end_inset

 ] && echo 
\begin_inset Quotes eld
\end_inset

ok
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ne produira pas d'erreur.
\end_layout

\begin_layout Itemize
Test sur les variables numériques :
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-eq
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-ne
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
not equal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-lt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
less than
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-gt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
greater than
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-le
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
less or equal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-ge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
greater or equal
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Test sur les fichiers :
\begin_inset Quotes erd
\end_inset

 $ test option nom_fichier
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
est un fichier normal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
est un repertoire
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
est un fichier en mode caractère
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
autorisation en lecture
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
autorisation en écriture
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
autorisation en execution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fichier non vide
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
le fichier existe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
le fichier est un lien symbolique
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
saisie de l'utilisateur
\end_layout

\begin_layout Standard
La commande read permet à l'utilisateur de saisir une chaine et de la placer
 dans une ou plusieurs variable.
 La saisie est validé par entré.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
center
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
option
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
affiche du texte avant la saisie
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stop la saisie après n caractère
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stop la saisie après t secondes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ read -p 
\begin_inset Quotes eld
\end_inset

entre la valeur
\begin_inset Quotes erd
\end_inset

 x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour faire une saisie dans un tableau non initialisé :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ read -p 
\begin_inset Quotes eld
\end_inset

entrez les valeurs séparer par un caractère
\begin_inset Quotes erd
\end_inset

 -a Tab
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Lecture d'un fichier ligne à ligne 
\end_layout

\begin_layout Standard
On lis un fichier ligne par ligne c'est à dire tant qu'il n'y a pas le caractère
 retour à la ligne.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cat toto.txt | while read ligne
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	echo $ligne
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ou encore 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

while read ligne
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	echo $ligne
\end_layout

\begin_layout Plain Layout

done < toto.txt
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
if...then...else
\end_layout

\begin_layout Standard
Si une condition se réalise, on effectue la commande, il faut faire attention
 à la syntaxe du bash : 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if [ $# -ne 0 ]   #attention à l'espacement
\end_layout

\begin_layout Plain Layout

then
\end_layout

\begin_layout Plain Layout

	echo aucun paramètre passé
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	echo 
\begin_inset Quotes eld
\end_inset

$# paramètre passé
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

fi
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
choix multiple case
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
case valeur in
\end_layout

\begin_layout Standard
model1) commande ;;
\end_layout

\begin_layout Standard
model2) commande ;;
\end_layout

\begin_layout Standard
*) action par défaut ;;
\begin_inset Newline newline
\end_inset

esac
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case $1 in
\end_layout

\begin_layout Plain Layout

	a*) echo 
\begin_inset Quotes eld
\end_inset

le mot commence par a
\begin_inset Quotes erd
\end_inset

 ;;
\end_layout

\begin_layout Plain Layout

	b*) echo 
\begin_inset Quotes eld
\end_inset

le mot commence par b ;;
\end_layout

\begin_layout Plain Layout

	fic[123]) echo 
\begin_inset Quotes eld
\end_inset

fic1 , fic2 ou fic3
\begin_inset Quotes erd
\end_inset

 ;;
\end_layout

\begin_layout Plain Layout

	*) echo  
\begin_inset Quotes eld
\end_inset

commence par n'importe quoi
\begin_inset Quotes erd
\end_inset

 ;;
\end_layout

\begin_layout Plain Layout

esac
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ monProg aurevoir
\end_layout

\begin_layout Plain Layout

	le mot commence par a
\end_layout

\begin_layout Plain Layout

$ monProg fic2
\end_layout

\begin_layout Plain Layout

	fic1, fic2 ou fic3
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
boucle for
\end_layout

\begin_layout Standard
la boucle for (en bash) ne se base pas sur une quelconque incrémentation
 numérique mais sur une liste de valeurs, de fichiers.
 
\end_layout

\begin_layout Standard
for var in liste
\end_layout

\begin_layout Standard
do
\end_layout

\begin_layout Standard
	commande à executer
\end_layout

\begin_layout Standard
done
\end_layout

\begin_layout Itemize
Avec une variable 
\begin_inset Quotes eld
\end_inset

$ ./MonProg fichier1 fichier2 ...
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for param in $@  
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	echo 
\begin_inset Quotes eld
\end_inset

$param
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
le script réécrit les variables passé en paramètre
\end_layout

\begin_layout Itemize
Avec une liste implicite
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Si vous ne précisez aucune liste dans la boucle for, alors c'est la liste
 des paramètres qui est implicite.
 Ainsi, le script précedent aurait pu ressembler à 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for param 
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	echo 
\begin_inset Quotes eld
\end_inset

$param
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Avec une liste explicite
\end_layout

\begin_layout Standard
Les élement situés après le 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

 seront utilisés pour faire la boucle for
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for param in liste1 liste2 liste3 
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	echo 
\begin_inset Quotes eld
\end_inset

$param
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Critère de recherche dans une arborescence
\end_layout

\begin_layout Standard
Si le script se situe dans un repertoire alors le caractère * listera tous
 les fichiers dans le répertoire.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for fic in *
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	ls -l $fic
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Avec un interval de valeur
\end_layout

\begin_layout Standard
Il existe 2 méthodes pour compter de 1 à n avec une boucle for.
 La première consiste à utiliser une substitution de commade avec la commande
 
\begin_inset Quotes eld
\end_inset

seq
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ seq(5)
\end_layout

\begin_layout Plain Layout

	1
\end_layout

\begin_layout Plain Layout

	2
\end_layout

\begin_layout Plain Layout

	3	
\end_layout

\begin_layout Plain Layout

	4
\end_layout

\begin_layout Plain Layout

	5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in $(seq(5)) 
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	echo $i
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La seconde méthode consiste à utiliser la syntaxe proche du C
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for ((a=1 ; a<=5 ; a++))
\end_layout

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

	echo $a
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Une méthode un peu plus barbare (mais beaucoup plus simple !) consiste à
 faire une plage de valeur :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in {0..20}
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	commande
\end_layout

\begin_layout Plain Layout

done
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Boucle while
\end_layout

\begin_layout Standard
La boucle while est similaire à la boucle for, en version indeterministe.
\end_layout

\begin_layout Standard
while condition
\end_layout

\begin_layout Standard
do
\end_layout

\begin_layout Standard
commande
\end_layout

\begin_layout Standard
done
\end_layout

\begin_layout Paragraph
boucle select
\end_layout

\begin_layout Standard
la commande select permet de créer des menus simples avec séléction par
 énumération.
 la saisie s'effectue au clavier avec le prompt de la variable PS3.
\end_layout

\begin_layout Standard
select variable in liste_contenu
\end_layout

\begin_layout Standard
do
\end_layout

\begin_layout Standard
traitement
\end_layout

\begin_layout Standard
done
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

PS3=
\begin_inset Quotes erd
\end_inset

votre choix
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

echo 
\begin_inset Quotes eld
\end_inset

quelle reponse ?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

select reponse in jules romain quitte
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	if [[ 
\begin_inset Quotes eld
\end_inset

$reponse
\begin_inset Quotes erd
\end_inset

 == 
\begin_inset Quotes eld
\end_inset

$quitte
\begin_inset Quotes erd
\end_inset

 ]]
\end_layout

\begin_layout Plain Layout

	then
\end_layout

\begin_layout Plain Layout

		break
\end_layout

\begin_layout Plain Layout

	fi
\end_layout

\begin_layout Plain Layout

	echo 
\begin_inset Quotes eld
\end_inset

vous avez choisi $reponse
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

echo 
\begin_inset Quotes eld
\end_inset

au revoir
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ./monProg
\end_layout

\begin_layout Plain Layout

$ quelle reponse ?
\end_layout

\begin_layout Plain Layout

$ 1) jules
\end_layout

\begin_layout Plain Layout

$ 2) romain
\end_layout

\begin_layout Plain Layout

$ 3) quitte
\end_layout

\begin_layout Plain Layout

$ votre choix : 3
\end_layout

\begin_layout Plain Layout

$ au revoir
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Les fonctions
\end_layout

\begin_layout Itemize
En bash :
\end_layout

\begin_layout Standard
Les fonctions sont des bouts de script nommés, directement appelée par leur
 nom, pouvant accepter des paramètres et retourner des valeurs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

nom_fonction ()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	commandes
\end_layout

\begin_layout Plain Layout

	return  	# (optionel)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
En KSH
\end_layout

\begin_layout Standard
on doit preceder le nom de la fonction par 
\begin_inset Quotes eld
\end_inset

function
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Quelques utilités 
\end_layout

\begin_layout Paragraph
commande shell rapide
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
commande
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
objectif
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
renvoie la dernière commande lancée
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
renvoie la dernière commande commançant par k
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bg
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
place un processus actif en arrière plan
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bg%3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
met le 3ème processus en arrière plan (en ordre de lancement chronologique)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fg
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
place le 1er processus lancé en le premier plan
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fg%2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
place le 2ème processus en premier plan
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jobs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retourne les processus lancé par un terminal spécifique
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Les Processus
\end_layout

\begin_layout Standard
sont toutes les tâches actuellement en cours d'exécution sur un ordinateur.
 On peut accéder à ces tâches en cours grâce à la commande ps
\end_layout

\begin_layout Standard
Cette commande dispose des options : 
\end_layout

\begin_layout Itemize
-e pour afficher tous les processus y compris ceux en arrière plan
\end_layout

\begin_layout Itemize
-a pour afficher les processus ouvert par le terminal
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ ps - a
\end_layout

\begin_layout Plain Layout

	PID TTY TIME CMD 
\end_layout

\begin_layout Plain Layout

	4882  pts/1 00:00:10 okular    
\end_layout

\begin_layout Plain Layout

	6232  pts/3 00:00:44 lyx    
\end_layout

\begin_layout Plain Layout

	6263  pts/3 00:00:11 okular
\end_layout

\begin_layout Plain Layout

    7344  pts/2 00:00:00 ps 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Dans cette exemple, on peut voir 4 processus possèdant chacun leur identité
 (PID), sur quelle port ils ont été lancés, le temps depuis leur exécution
 ainsi que les applications ou commandes utilisées.
 On peut voir qu'il y a une application lyx en cours lancé par le terminal
 3, 2 application de lecture de pdf (okular), une lancée par le terminal
 1 et l'autre sur le terminal 3 ainsi que la commande ps lancée sur le terminal
 2 !
\end_layout

\begin_layout Standard
On peut 
\begin_inset Quotes eld
\end_inset

tuer
\begin_inset Quotes erd
\end_inset

 les processus lancé par linux avec la commande kill, dans ce cas, il suffit
 juste de spécifier le PID du processus.
\end_layout

\begin_layout Paragraph
Regroupement de fichiers / Compression
\end_layout

\begin_layout Standard
Pour regrouper des fichiers dans un même dossier, on créer d'abord ce dossier,
 disons REP.
 Ensuite, on vient placer les fichiers dont on veut regrouper dans ce répertoire.
 Grâce à la commande tar, on peut réaliser une véritable archive de fichier
 prête à être compresser avec la commande gzip.
\end_layout

\begin_layout Standard
Info sur la commande tar par linux :
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

For  example,  the c option requires creating the archive, the v option
        
\end_layout

\begin_layout Plain Layout

requests the verbose operation, and the f option takes an argument that
        
\end_layout

\begin_layout Plain Layout

sets  the  name of the archive to operate upon.
  The following command,        
\end_layout

\begin_layout Plain Layout

written in the traditional style, instructs tar to store all files from
        
\end_layout

\begin_layout Plain Layout

the  directory /etc into the archive file etc.tar verbosely listing the 
       
\end_layout

\begin_layout Plain Layout

files being archived:
\end_layout

\begin_layout Plain Layout

       tar cfv etc.tar /etc 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Paragraph
cron 
\end_layout

\begin_layout Standard
Et que diriez vous d'automatiser certaines tâches quotidiennement ?! Par
 exemple sauvegarder un fichier dans un autre endroit sans avoir à tous
 resynchroniser vos fichiers, ou bien vider le cache de votre pc.
 C'est possible grâce à la commande cron, ou plutôt le 
\begin_inset Quotes eld
\end_inset

daemon
\begin_inset Quotes erd
\end_inset

 cron.
 Voyez les 
\begin_inset Quotes eld
\end_inset

daemon
\begin_inset Quotes erd
\end_inset

 comme des notifications dans linux.
\end_layout

\begin_layout Standard
Pour mettre en place des tâches quotidiennes il faut evant tout les ecrires
 dans un fichier nommé crontab.
 Vous pouves listez les tâches automatiser avec la commande 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ crontab -l
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bien entendu si vous n'y avait jamais touché, ce fichier est vide, voir
 même qu'il n'existe pas.
 Pour pouvoir le modifier, il faut tout d'abord attribué un editeur de fichier
 à la variable EDITOR ( elle fait partie des variables quand vous taper
 la commande env
\begin_inset Quotes erd
\end_inset

).
 Si vous lancé pour la première fois la commande 
\begin_inset Quotes eld
\end_inset

crontab -e
\begin_inset Quotes erd
\end_inset

 sans définir votre editeur préféré, votre terminal va vous demandez de
 choisir entre diffèrentes options parmi vos éditeurs de texte installés.
 Pour éviter de faire cette manipulation à chaques fois, il faut exporter
 votre editeur dans la variable EDITOR .
 Par exemple, si vous souhaité l'ouvrir avec vim :
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ export EDITOR=vim 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
sinon avec nano, un autre éditeur de texte orienté terminal, EDITOR=nano.
 Ou bien si vous êtes un habitué du geany, export EDITOR=geany.
\end_layout

\begin_layout Standard
Bon maintenant, les choses intéressantes, une fois dans votre fichier crontab,
 que vous avez ouvert simplement avec la commande 
\begin_inset Quotes eld
\end_inset

crontab -e
\begin_inset Quotes erd
\end_inset

 après avoir définie votre éditeur, il va falloir respecter quelques syntaxes.
\end_layout

\begin_layout Standard
Voici de manière schématique la syntaxe à respecter d'un crontab:
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Example of job definition: 
\end_layout

\begin_layout Plain Layout

# .---------------- minute (0 - 59) 
\end_layout

\begin_layout Plain Layout

# |  .------------- hour (0 - 23) 
\end_layout

\begin_layout Plain Layout

# |  |  .---------- day of month (1 - 31) 
\end_layout

\begin_layout Plain Layout

# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
 
\end_layout

\begin_layout Plain Layout

# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fr
i,sat 
\end_layout

\begin_layout Plain Layout

# |  |  |  |  | 
\end_layout

\begin_layout Plain Layout

# *  *  *  *  *  user command to be executed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Pour chaque unité, on peut utiliser les notations suivantes :
\end_layout

\begin_layout Standard
1-5 : les unités de temps de 1 à 5
\end_layout

\begin_layout Standard
*/6 : toutes les 6 unités de temps (toutes les 6 heures par exemple)
\end_layout

\begin_layout Standard
2,7 : les unités de temps 2 et 7.
\end_layout

\begin_layout Standard
Exemple 
\end_layout

\begin_layout Standard
Exécution tous les jours à 22h00 d'une commande et rediriger les infos dans
 sauvegarde.log :
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

00 22 * * * /root/scripts/sauvegarde.sh >> sauvegarde.log
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Exécution d'une commande toutes les 6 heures :
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

00 */6 * * * /root/scripts/synchronisation-ftp.sh
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Exécution d'une commande une fois par an à une heure précise (ici le 25
 décembre à 00h15) : 
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 15 00 25 12 * echo "Le père Noël est passé !"
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Pour supprimer toutes les tâches automatisé du fichier crontab, il suffit
 de taper la commande 
\begin_inset Quotes eld
\end_inset

crontab -r
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph*
rsync
\end_layout

\begin_layout Standard
Pour faire en sorte que deux répertoires différents possèdent le même contenu
 sur Linux, vous pouvez utiliser la commande rsync.
 Rsync est un outil de synchronisation de fichiers qui vous permet de copier
 les fichiers et répertoires de manière efficace, en ne transférant que
 les modifications.
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ rsync -avz /chemin/vers/répertoire_source/ /chemin/vers/répertoire_destination
/
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
l'option -a préserve les permissions, -z compresse les données pour de meilleur
 performance et -v pour avoir un visuel (optionel).
 Et maintenant, on a tous les joués à notre disposition pour faire de belle
 sauvegarde.
 Par exemple si vous souhaitez automatisez la syncronisation de 2 répertoires,
 il suffit d'inserer cette commande dans le fichier crontab !
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

00 22 * * *  rsync -avz /chemin/vers/répertoire_source/ /chemin/vers/répertoire_
destination/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cas pratiques
\end_layout

\begin_layout Paragraph
récupération des champs d'une commande 
\end_layout

\begin_layout Standard
Prenons l'exemple de la commande date qui retourne 6 champs : 
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sam.
 20 mai 2023 21:43:46 CEST 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Imaginons que l'on souhaite récupérer l'année.
 Une première méthode serait d'utiliser la commande cut :
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

annee=$(date | cut -d 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

 -f 4)
\end_layout

\end_inset


\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
Une deuxième méthode serait d'utiliser la commande 'set'.
 Cette commande permet d'exporter des valeurs à travers votre shell.
 Par exemple :
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ set `date`
\end_layout

\begin_layout Plain Layout

$ echo $1
\end_layout

\begin_layout Plain Layout

	sam.
\end_layout

\begin_layout Plain Layout

$ echo $2
\end_layout

\begin_layout Plain Layout

	20
\end_layout

\begin_layout Plain Layout

$ echo $3
\end_layout

\begin_layout Plain Layout

	mai
\end_layout

\begin_layout Plain Layout

$ echo $4
\end_layout

\begin_layout Plain Layout

	2023
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.5cm
\end_inset

Bingo ! On a récupérer l'année en une seul commande !
\end_layout

\end_body
\end_document
